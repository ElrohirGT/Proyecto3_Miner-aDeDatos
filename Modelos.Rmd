---
title: "Modelos"
author: "Flavio Galán, Gustavo Cruz, Pedro Guzmán"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true # table of content true
    toc_float: true  # upto three depths of headings (specified by #, ## and ###)
    theme: paper  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r Cargar librerias}
library(rio)
library(janitor)
library(ggplot2)
library(dplyr)
library(tidyr)
library(viridis)
library(scales)
library(readxl)
library(purrr)
library(plotly)
library(fastDummies)
library(hopkins)
library(fpc)
library(factoextra)
library(cluster) #Para calcular la silueta
library(e1071)#para cmeans
library(mclust) #mixtures of gaussians
library(NbClust) #Para determinar el número de clusters óptimo
library(GGally) #Para hacer el conjunto de graficos
library(FeatureImpCluster) #Para revisar la importancia de las variables en los grupos.
library(pheatmap)
library(flexclust)
library(ggrepel)
# Dependencias necesarias para el random Forest
# Ahora se usa ranger para randomForest y parallel para paralelizar y que sea mas rapido entrenar
library(randomForest) # al principio se uso randomForest pero era muy lento
library(ranger)
library(parallel)
library(caret)
library(forcats)
library(data.table)
library(tidyverse)
library(rpart)
library(rpart.plot)
```

# Modelos con Algoritmos

Determinamos que la variable respuesta para nuestra investigación sería el ratio que describimos con anterioridad en el análisis exploratorio entre la edad de la víctima y el agresor. La cual se encuentra definida como:

$$
q=\frac{edad\ victima}{edad\ agresor}
$$

Este nuevo indicador "q" lo dividimos en 3 categorías, según qué tanta diferencia de edad se encontró entre víctimas y agresores. Las categrías son las siguientes:

* Edad similar. El $q\in(0.8,1.2)$.
* Victima mucho menor. El $q \le 0.8$.
* Victima mucho mayor. El $q \ge 1.2$.

## División de los datos

Primero, tenemos que unir todos los datasets de los años anteriores, entonces

```{r Unión de los datos}

original <- import("Datos/2023.sav")

addToDataset <- function(year) {
  data <- import(paste("Datos/", year, ".sav", sep=""))
  # reduced <- data[,colnames(original)]
  original <<- bind_rows(original, data)
}

ifValueConvertToNA <- function(column, values) {
  # print(paste("Removing ignored values from:", column))
  original[,c(column)] <<- ifelse(original[,c(column)] %in% values, NA, original[,c(column)])
}

for (year in 2013:2022) {
  addToDataset(year)
}

ignoredValues <- c(9, 99, 999, 9999)
affectedColumns <- c(
  "VIC_EDAD",
  "TOTAL_HIJOS",
  "NUM_HIJ_HOM",
  "NUM_HIJ_MUJ",
  "VIC_ALFAB",
  "VIC_ESCOLARIDAD",
  "VIC_EST_CIV",
  "VIC_GRUPET",
  "VIC_NACIONAL",
  "VIC_TRABAJA",
  "VIC_OCUP",
  "VIC_DEDICA",
  "VIC_DISC",
  "TIPO_DISCAQ",
  "OTRAS_VICTIMAS",
  "VIC_OTRAS_HOM",
  "VIC_OTRAS_MUJ",
  "VIC_OTRAS_N_OS",
  "VIC_OTRAS_N_AS",
  "HEC_DIA",
  "HEC_MES",
  "HEC_ANO",
  "HEC_DEPTO",
  "HEC_DEPTOMCPIO",
  "HEC_AREA",
  "HEC_RECUR_DENUN",
  "INST_DONDE_DENUNCIO",
  "AGR_EDAD",
  "AGR_ALFAB",
  "AGR_ESCOLARIDAD",
  "AGR_EST_CIV",
  "AGR_GURPET",
  "AGR_NACIONAL",
  "AGR_TRABAJA",
  "AGR_OCUP",
  "AGR_DEDICA",
  "AGRESORES_OTROS_TOTAL",
  "AGR_OTROS_HOM",
  "AGR_OTRAS_MUJ",
  "AGR_OTROS_N_OS",
  "AGR_OTRAS_N_AS",
  "CONDUCENTE",
  "LEY_APLICABLE",
  "ARTICULOVIF1",
  "ARTICULOVIF2",
  "ARTICULOVIF3",
  "ARTICULOVIF4",
  "ARTICULOVCM1",
  "ARTICULOVCM2",
  "ARTICULOVCM3",
  "ARTICULOVCM4",
  "ARTICULOCODPEN1",
  "ARTICULOCODPEN2",
  "ARTICULOCODPEN3",
  "ARTICULOCODPEN4",
  "ARTICULOTRAS1",
  "ARTICULOTRAS2",
  "ARTICULOTRAS3",
  "ARTICULOTRAS4",
  "MEDIDAS_SEGURIDAD",
  "ORGANISMO_REMITE",
  "QUIEN_REPORTA",
  "ORGANISMO_JURISDICCIONAL"
)


for (col in affectedColumns) {
	ifValueConvertToNA(col, ignoredValues)
}

# Ignorar también TIPO_MEDIDA, se ignora con valor z
ifValueConvertToNA("TIPO_MEDIDA", c("z"))

# Por alguna razón se crea esta columna, todos sus valores son NAN así que la borramos.
original$`filter_$` <- NULL

summary(original)
```

Ahora creamos la variable respuesta:
```{r creacion de variable respuesta}
edad_agr_vic <- original %>%
  filter(!is.na(VIC_EDAD) & !is.na(AGR_EDAD)) %>%
  mutate(
    ratio_age = VIC_EDAD / AGR_EDAD,
    diferenciaEdad = ifelse(ratio_age <= 0.8, "Mucho menor", ifelse(ratio_age <= 1.2, "Similar", "Mucho mayor")) 
  )

summary(edad_agr_vic)
```

Con esto podemos decir que el dataset tiene `r ncol(edad_agr_vic)` variables y `r nrow(edad_agr_vic)` observaciones.

Vemos que hay variables con una gran presencia de NA's, por esa razón eliminaremos aqueellas variables que tengan más del 50% de valores en NA. 

```{r}
# Función para eliminar columnas con más del 50% de NA
eliminar_columnas_por_na <- function(df, variables_a_evaluar) {
  
  # Verificar que las variables a evaluar existan en el data.frame
  variables_existentes <- intersect(variables_a_evaluar, names(df))
  
  if (length(variables_existentes) == 0) {
    message("Ninguna de las variables especificadas existe en el data.frame.")
    return(df)
  }
  
  if (length(variables_existentes) < length(variables_a_evaluar)) {
    warning("Algunas de las variables especificadas no se encontraron en el data.frame y serán omitidas de la evaluación.")
  }
  
  # Calcular el umbral de NA (50% del total de filas)
  umbral_na <- 0.5 * nrow(df)
  
  # Identificar las columnas a eliminar
  columnas_a_eliminar <- c()
  for (col_name in variables_existentes) {
    if (sum(is.na(df[[col_name]])) > umbral_na) {
      columnas_a_eliminar <- c(columnas_a_eliminar, col_name)
    }
  }
  
  # Eliminar las columnas identificadas
  if (length(columnas_a_eliminar) > 0) {
    message(paste("Se eliminarán las siguientes columnas debido a que superan el 50% de NA:", 
                  paste(columnas_a_eliminar, collapse = ", ")))
    df_limpio <- df[, !(names(df) %in% columnas_a_eliminar)]
  } else {
    message("No se encontraron columnas que superen el 50% de NA entre las variables especificadas.")
    df_limpio <- df
  }
  
  return(df_limpio)
}



qualitative_vars <- c(
  "HEC_DEPTO", "DEPTO_MUNICIPIO", "QUIEN_REPORTA", "VIC_SEXO", 
  "VIC_ALFAB", "VIC_ESCOLARIDAD", "VIC_EST_CIV", "VIC_GRUPET", 
  "VIC_NACIONAL", "VIC_TRABAJA", "VIC_OCUP", "VIC_DEDICA", 
  "VIC_DISC", "TIPO_DISCAQ", "HEC_AREA", "HEC_TIAGRE", 
  "HEC_RECUR_DENUN", "INST_DONDE_DENUNCIO", "AGR_SEXO", 
  "AGR_ALFAB", "AGR_ESCOLARIDAD", "AGR_EST_CIV", "AGR_GRUPET", 
  "AGR_NACIONAL", "AGR_TRABAJA", "AGR_OCUP", "AGR_DEDICA", 
  "INST_DENUN_HECHO", "ORGANISMO_JURISDICCIONAL", "CONDUCENTE", 
  "MEDIDAS_SEGURIDAD", "LEY_APLICABLE", "ARTICULOVIF", 
  "ARTICULOVCM", "ARTICULOCODPEN", "ARTICULOTRAS", 
  "TIPO_MEDIDA", "ORGANISMO_REMITE"
)


result <- eliminar_columnas_por_na(edad_agr_vic, qualitative_vars)

```


Con lo cual decidimos dividir el dataset en 2 grupos, uno de validación y otro para entrenamiento, el de validación tiene el 30% de los datos mientras que el de entrenamiento el 70%. Los grupos se ven así:

```{r División en entrenamiento y validación}
set.seed(69420)
train_index <- createDataPartition(edad_agr_vic$diferenciaEdad, p = 0.7, list = FALSE)
train <- edad_agr_vic[train_index,]
test <- edad_agr_vic[-train_index,]

ggplotly(ggplot(train, aes(x=diferenciaEdad)) +
  geom_bar(fill = "skyblue") +
  labs(title="Datos de Entrenamiento", x = "Categoria", y = "Cuenta"))


ggplotly(ggplot(test, aes(x=diferenciaEdad)) +
  geom_bar(fill = "orange") +
  labs(title = "Datos de Validacion", x = "Categoria", y = "Cuenta"))
```

Como se puede ver existe una alta desigualdad en los datos, puesto que la gran mayoría de los casos se dan cuando la víctima tiene una edad similar al agresor. Definitivamente esto será algo a tomar en cuenta durante el entrenamiento del modelo, uno de las posibles optimizaciones a evaluar podría ser balancear la data de entrenamiento para mejorar la precisión.

## Balanceo y optiminzación


```{r}
# Para el conjunto de entrenamiento: 21,000 observaciones (7,000 por categoría)
train_balanceado <- train %>%
  group_by(diferenciaEdad) %>%
  sample_n(35000) %>%
  ungroup()

# Verificar el balance en el conjunto de entrenamiento
table(train_balanceado$diferenciaEdad)

# Para el conjunto de prueba: 9,000 observaciones (3,000 por categoría)
test_balanceado <- test %>%
  group_by(diferenciaEdad) %>%
  sample_n(15000) %>%
  ungroup()

# Verificar el balance en el conjunto de prueba
table(test_balanceado$diferenciaEdad)
```




## Modelos elegidos

Se decidió utilizar el modelo random forest ya qu, a pesar de su alto coste computacional, en entregas anteriores se ha determinado que este algoritmo ofrece una mayor presición a la hora de calificar o predecir la información. Para realizar los modelos se realizarán las siguietes transformaciones al conjunto de datos: 


- Sustituir los valores NA en las variables numéricas con el valor de la mediana. 
- Cambiar los NA en las varibles categóricas a una nueva categoría llamada "Desconocido"
- Crear una nueva varible llamadaratio age la cuál será el cociente entre la edad del agresor y la de la víctima
- Tunear el número de variables y el split de variables en cada uno de los nuevos modelos a genenrar.

## Random forest

```{r Modelos rf}
ncores <- min(detectCores() - 1, 24)  # Limitamos a un máximo práctico

robust_impute <- function(df) {
  df_copy <- copy(df)
  
  for (col in names(df_copy)) {
    if (is.numeric(df_copy[[col]])) {
      na_idx <- which(is.na(df_copy[[col]]))
      if (length(na_idx) > 0) {
        if (all(is.na(df_copy[[col]]))) {
          set(df_copy, na_idx, col, 0)
        } else {
          med_val <- median(df_copy[[col]], na.rm = TRUE)
          set(df_copy, na_idx, col, med_val)
        }
      }
    } 
    else if (is.factor(df_copy[[col]])) {
      na_idx <- which(is.na(df_copy[[col]]))
      if (length(na_idx) > 0) {
        if (all(is.na(df_copy[[col]]))) {
          if (!("Desconocido" %in% levels(df_copy[[col]]))) {
            levels(df_copy[[col]]) <- c(levels(df_copy[[col]]), "Desconocido")
          }
          set(df_copy, na_idx, col, "Desconocido")
        } else {
          freq_table <- table(df_copy[[col]], useNA = "no")
          if (length(freq_table) > 0) {
            most_freq <- names(which.max(freq_table))
            set(df_copy, na_idx, col, most_freq)
          } else {
            if (!("Desconocido" %in% levels(df_copy[[col]]))) {
              levels(df_copy[[col]]) <- c(levels(df_copy[[col]]), "Desconocido")
            }
            set(df_copy, na_idx, col, "Desconocido")
          }
        }
      }
    }
    else if (is.character(df_copy[[col]])) {
      df_copy[[col]] <- as.factor(df_copy[[col]])
      na_idx <- which(is.na(df_copy[[col]]))
      if (length(na_idx) > 0) {
        set(df_copy, na_idx, col, "Desconocido")
      }
    }
    else {
      na_idx <- which(is.na(df_copy[[col]]))
      if (length(na_idx) > 0) {
        df_copy[[col]] <- as.character(df_copy[[col]])
        set(df_copy, na_idx, col, "Desconocido")
        df_copy[[col]] <- as.factor(df_copy[[col]])
      }
    }
  }
  
  if (any(is.na(df_copy))) {
    na_cols <- colnames(df_copy)[colSums(is.na(df_copy)) > 0]
    message("ADVERTENCIA: Eliminando columnas con NAs persistentes: ", paste(na_cols, collapse=", "))
    df_copy <- df_copy[, .SD, .SDcols = setdiff(names(df_copy), na_cols)]
  }
  
  return(df_copy)
}

train_imp <- robust_impute(copy(train_balanceado))
test_imp <- robust_impute(copy(test_balanceado))

for (col in names(train_imp)) {
  if (is.factor(train_imp[[col]]) && col %in% names(test_imp)) {
    train_levels <- levels(train_imp[[col]])
    test_levels <- levels(test_imp[[col]])
    
    all_levels <- unique(c(train_levels, test_levels))
    
    train_imp[[col]] <- factor(train_imp[[col]], levels = all_levels)
    test_imp[[col]] <- factor(test_imp[[col]], levels = all_levels)
  }
}

for (col in names(train_imp)) {
  if (is.factor(train_imp[[col]]) && length(levels(train_imp[[col]])) > 20) {
    top_levels <- names(sort(table(train_imp[[col]]), decreasing = TRUE)[1:20])
    
    if (length(top_levels) == 0) {
      train_imp[[col]] <- as.character(train_imp[[col]])
      test_imp[[col]] <- as.character(test_imp[[col]])
      next
    }
    
    train_levels_to_change <- setdiff(levels(train_imp[[col]]), c(top_levels, "Other"))
    if (length(train_levels_to_change) > 0) {
      levels(train_imp[[col]])[match(train_levels_to_change, levels(train_imp[[col]]))] <- "Other"
    }
    
    test_levels_to_change <- setdiff(levels(test_imp[[col]]), c(top_levels, "Other"))
    if (length(test_levels_to_change) > 0) {
      levels(test_imp[[col]])[match(test_levels_to_change, levels(test_imp[[col]]))] <- "Other"
    }
    
    combined_levels <- unique(c(levels(train_imp[[col]]), levels(test_imp[[col]])))
    train_imp[[col]] <- factor(train_imp[[col]], levels = combined_levels)
    test_imp[[col]] <- factor(test_imp[[col]], levels = combined_levels)
  }
}

if (any(is.na(train_imp)) || any(is.na(test_imp))) {
  na_cols_train <- names(train_imp)[colSums(is.na(train_imp)) > 0]
  na_cols_test <- names(test_imp)[colSums(is.na(test_imp)) > 0]
  problem_cols <- unique(c(na_cols_train, na_cols_test))
  
  if (length(problem_cols) > 0) {
    message("ADVERTENCIA: Eliminando columnas problemáticas como último recurso: ", 
           paste(problem_cols, collapse=", "))
    
    if ("ratio_age" %in% problem_cols) {
      stop("La variable objetivo 'ratio_age' contiene NAs que no se pueden eliminar. Revisa tus datos.")
    }
    
    cols_to_keep <- setdiff(names(train_imp), problem_cols)
    train_imp <- train_imp[, ..cols_to_keep]
    test_imp <- test_imp[, ..cols_to_keep]
  }
}

stopifnot("Aún hay NAs en train_imp" = sum(is.na(train_imp)) == 0)
stopifnot("Aún hay NAs en test_imp" = sum(is.na(test_imp)) == 0)

p <- ncol(train_imp) - 1  

# Modelo 1: Menos árboles, menos variables por split (enfoque conservador)
train_model1 <- function() {
  set.seed(123)
  ranger(
    ratio_age ~ ., 
    data = train_imp,
    num.trees = 200,                 # Menos árboles para velocidad
    mtry = floor(sqrt(p)),           # Enfoque tradicional: sqrt(p)
    min.node.size = 15,              # Nodos más grandes (menos sobreajuste)
    max.depth = 15,                  # Profundidad limitada
    sample.fraction = 0.7,           # Submuestreo
    num.threads = ncores,
    verbose = FALSE,                 
    importance = "impurity"          # Más rápido
  )
}

# Modelo 2: Número medio de árboles, más variables por split
train_model2 <- function() {
  set.seed(456)
  ranger(
    ratio_age ~ ., 
    data = train_imp,
    num.trees = 300,                 # Más árboles, mejor generalización
    mtry = floor(p/3),               # Más variables por split
    min.node.size = 5,               # Nodos más pequeños
    max.depth = 25,                  # Mayor profundidad
    sample.fraction = 0.8,           # Más muestras
    num.threads = ncores,
    verbose = FALSE,
    importance = "impurity"
  )
}

# Modelo 3: Más árboles, balance de variables
train_model3 <- function() {
  set.seed(789)
  ranger(
    ratio_age ~ ., 
    data = train_imp,
    num.trees = 500,                 # Muchos árboles
    mtry = floor(p * 0.4),           # Balance de variables
    min.node.size = 10,              # Balance en tamaño de nodos
    max.depth = 20,                  # Balance en profundidad
    sample.fraction = 0.75,          # Balance en submuestreo
    num.threads = ncores,
    verbose = FALSE,
    importance = "impurity"
  )
}

message("Entrenando modelo 1 (Conservador)")
rf1 <- train_model1()
message("Entrenando modelo 2 (Intermedio)")
rf2 <- train_model2()
message("Entrenando modelo 3 (Agresivo)")
rf3 <- train_model3()

pred1 <- predict(rf1, data = test_imp)$predictions
pred2 <- predict(rf2, data = test_imp)$predictions
pred3 <- predict(rf3, data = test_imp)$predictions

calc_metrics <- function(pred, actual) {
  c(
    MAE = mean(abs(pred - actual)),
    RMSE = sqrt(mean((pred - actual)^2)),
    R2 = 1 - sum((actual - pred)^2) / sum((actual - mean(actual))^2)
  )
}

metrics1 <- calc_metrics(pred1, test_imp$ratio_age)
metrics2 <- calc_metrics(pred2, test_imp$ratio_age)
metrics3 <- calc_metrics(pred3, test_imp$ratio_age)

# Comparamos los modelos
all_metrics <- rbind(
  Model1 = metrics1,
  Model2 = metrics2,
  Model3 = metrics3
)

# Graficos para ayudar a entender el rendimiento de los modelos rf creados y entrenados anteriormente
if (require(ggplot2)) {
  metrics_df <- as.data.frame(all_metrics)
  metrics_df$Modelo <- rownames(metrics_df)
  
  # Tabla de métricas
  print("Tabla de métricas de los tres modelos:")
  print(all_metrics)
  
  # Gráfico de barras de RMSE
  ggplot(metrics_df, aes(x = Modelo, y = RMSE, fill = Modelo)) +
    geom_bar(stat = "identity") +
    geom_text(aes(label = round(RMSE, 4)), vjust = -0.5) +
    labs(title = "Comparación de RMSE entre modelos",
         y = "RMSE (menor es mejor)") +
    theme_minimal() +
    theme(legend.position = "none")
  
  # Gráficos de predicción vs real para cada modelo
  prediction_df <- data.frame(
    Real = test_imp$ratio_age,
    Modelo1 = pred1,
    Modelo2 = pred2,
    Modelo3 = pred3
  )
  
  # Gráfico para Modelo 1
  plot_pred1 <- ggplot(prediction_df, aes(x = Real, y = Modelo1)) +
    geom_point(alpha = 0.5, color = "blue") +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    labs(title = "Predicción vs Valor Real (Modelo 1)",
         x = "Ratio de Edad Real",
         y = "Ratio de Edad Predicho") +
    theme_minimal() +
    annotate("text", x = min(prediction_df$Real), y = max(prediction_df$Modelo1), 
             label = paste("RMSE:", round(metrics1["RMSE"], 4)), hjust = 0)
  
  # Gráfico para Modelo 2
  plot_pred2 <- ggplot(prediction_df, aes(x = Real, y = Modelo2)) +
    geom_point(alpha = 0.5, color = "green") +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    labs(title = "Predicción vs Valor Real (Modelo 2)",
         x = "Ratio de Edad Real",
         y = "Ratio de Edad Predicho") +
    theme_minimal() +
    annotate("text", x = min(prediction_df$Real), y = max(prediction_df$Modelo2), 
             label = paste("RMSE:", round(metrics2["RMSE"], 4)), hjust = 0)
  
  # Gráfico para Modelo 3
  plot_pred3 <- ggplot(prediction_df, aes(x = Real, y = Modelo3)) +
    geom_point(alpha = 0.5, color = "purple") +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    labs(title = "Predicción vs Valor Real (Modelo 3)",
         x = "Ratio de Edad Real",
         y = "Ratio de Edad Predicho") +
    theme_minimal() +
    annotate("text", x = min(prediction_df$Real), y = max(prediction_df$Modelo3), 
             label = paste("RMSE:", round(metrics3["RMSE"], 4)), hjust = 0)
  
  print(plot_pred1)
  print(plot_pred2)
  print(plot_pred3)
}

```
## Modelo final de random forest

Se exploraron tres modelos de Random Forest con diferentes configuraciones de parámetros para predecir la variable ratio_age. El Modelo 1, cuenta con menos árboles, menos variables por división y nodos más grandes, en comparación del modelo 2 y 3, y mostró un RMSE relativamente alto de 0.2712 y un R2 de 0.8307. El gráfico de dispersión revela una mayor dispersión de los puntos alrededor de la línea de predicción perfecta, indicando una menor precisión en las predicciones. En contraste, el Modelo 2, que empleó un mayor número de árboles, más variables por división y nodos más pequeños, demostró una mejora significativa en el rendimiento, con un RMSE de 0.096 y un R2 de 0.9788. El gráfico correspondiente exhibe una concentración mucho mayor de los puntos cerca de la línea de predicción ideal, lo que sugiere predicciones más precisas. Finalmente, el Modelo 3, que buscó un equilibrio en el número de árboles, la cantidad de variables por división y el tamaño de los nodos, logró los mejores resultados con un RMSE de 0.0824 y un R2 de 0.9844. Su gráfico de dispersión muestra la menor dispersión de los puntos, indicando la mayor exactitud predictiva entre los tres modelos.

La elección de estos parámetros se basó en la búsqueda de un equilibrio entre la capacidad del modelo para capturar patrones complejos en los datos y la necesidad de evitar el sobreajuste. El Modelo 1, al ser más conservador, probablemente incurrió en un mayor sesgo al no permitir suficiente flexibilidad en el aprendizaje. Los Modelos 2 y 3, al aumentar la complejidad, más árboles y más variables consideradas en cada división, lograron reducir significativamente el error. 

```{r Modelo final}

# Determinamos el mejor modelo basado en RMSE
best_idx <- which.min(all_metrics[, "RMSE"])
best_model_name <- paste("Modelo", best_idx)

message("El mejor modelo es ", best_model_name, " con RMSE = ", all_metrics[best_idx, "RMSE"])

var_importance <- switch(best_idx,
  "1" = importance(rf1),
  "2" = importance(rf2),
  "3" = importance(rf3)
)

var_importance <- sort(var_importance, decreasing = TRUE)

message("Entrenando modelo FINAL con parámetros optimizados")
best_params <- switch(best_idx,
  "1" = list(trees = 200, mtry = floor(sqrt(p)), node_size = 15, depth = 15, fraction = 0.7),
  "2" = list(trees = 500, mtry = floor(p/3), node_size = 5, depth = 25, fraction = 0.8),
  "3" = list(trees = 800, mtry = floor(p * 0.4), node_size = 10, depth = 20, fraction = 0.75)
)

# Creamos un modelo final con los parámetros optimizados
set.seed(2077)
rf_final <- ranger(
  ratio_age ~ ., 
  data = train_imp,
  num.trees = best_params$trees + 100,    # Aumentamos ligeramente los árboles
  mtry = best_params$mtry,                # Mantenemos la mejor configuración de variables
  min.node.size = best_params$node_size,  # Mantenemos el mejor tamaño de nodo
  max.depth = best_params$depth,          # Mantenemos la mejor profundidad
  sample.fraction = best_params$fraction, # Mantenemos la mejor fracción de muestreo
  num.threads = ncores,
  verbose = FALSE,
  importance = "impurity"
)

pred_final <- predict(rf_final, data = test_imp)$predictions
final_metrics <- c(
  MAE = mean(abs(pred_final - test_imp$ratio_age)),
  RMSE = sqrt(mean((pred_final - test_imp$ratio_age)^2)),
  R2 = 1 - sum((test_imp$ratio_age - pred_final)^2) / 
       sum((test_imp$ratio_age - mean(test_imp$ratio_age))^2)
)

message("Resultados del modelo FINAL:")
print(final_metrics)

if (require(ggplot2)) {
  # Tabla comparativa: mejor modelo inicial vs modelo final
  best_model_metrics <- all_metrics[best_idx,]
  comparison_metrics <- rbind(
    "Mejor Modelo Inicial" = best_model_metrics,
    "Modelo Final Optimizado" = final_metrics
  )
  print("Comparación entre el mejor modelo inicial y el modelo final:")
  print(comparison_metrics)
  
  # Gráfico mejorado de predicción vs real para el modelo final
  prediction_final_df <- data.frame(
    Real = test_imp$ratio_age,
    Predicho = pred_final
  )
  
  # Añadimos línea de regresión y error
  plot_final <- ggplot(prediction_final_df, aes(x = Real, y = Predicho)) +
    geom_point(alpha = 0.5, color = "darkgreen") +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    geom_smooth(method = "lm", color = "blue", se = TRUE) +
    labs(title = "Predicción vs Valor Real (Modelo FINAL)",
         subtitle = paste("RMSE:", round(final_metrics["RMSE"], 4), 
                          "| R²:", round(final_metrics["R2"], 4)),
         x = "Ratio de Edad Real",
         y = "Ratio de Edad Predicho") +
    theme_minimal() +
    coord_fixed(ratio = 1) +
    theme(plot.title = element_text(face = "bold"),
          plot.subtitle = element_text(color = "darkblue"))

  print(plot_final)
}

# Gráfico de predicción vs real
if (require(ggplot2)) {
  prediction_df <- data.frame(
    Real = test_imp$ratio_age,
    Predicho = pred_final
  )
  
  plot_pred <- ggplot(prediction_df, aes(x = Real, y = Predicho)) +
    geom_point(alpha = 0.5) +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    labs(title = "Predicción vs Valor Real",
         x = "Ratio de Edad Real",
         y = "Ratio de Edad Predicho") +
    theme_minimal()
  
  print(plot_pred)
}

message("Resumen de importancia de variables (top 5):")
print(head(var_importance, 5))
message("Análisis completado. El modelo final ha sido guardado como 'rf_model_final.rds'")
```

Debido a los resultados obtenidos de los 3 modelos iniciales, el Modelo 3 se eligió como el de mejor rendimiento en el conjunto de prueba, con un RMSE de 0.0824 y un R2 de 0.9844. Basándonos en la configuración de hiperparámetros de este modelo, se entrenó un Modelo Final Optimizado, realizando un ligero ajuste al aumentar el número de árboles a 600. La evaluación de este modelo final en el conjunto de prueba resultó en una ligera mejora en las métricas de rendimiento, alcanzando un MAE de 0.0120, un RMSE de 0.0821 y un R2 de 0.9845. 

El gráfico de dispersión del modelo final muestra una concentración aún mayor de los puntos alrededor de la línea de predicción perfecta, lo que indica una alta precisión en las predicciones. 
No obstante, la mejora marginal también indica que el modelo inicial ya se encontraba muy cerca de su máximo potencial con los datos disponibles. En cuanto al sobreajuste, la consistencia en el rendimiento entre el mejor modelo inicial y el modelo final en el conjunto de prueba, incluso con un ligero aumento en la complejidad al añadir más árboles, sugiere que el modelo final generaliza bien a datos no vistos y no presenta signos evidentes de sobreajuste. El alto R2 indica que una gran proporción de la varianza en la variable objetivo es explicada por el modelo, mientras que el bajo RMSE señala que las diferencias entre los valores predichos y reales son pequeñas.



## Árbol de decisión

Paraeste algoritmo realizaremos un árbol de clasificación, primero haremos un mapeo de las claves numéricas hcia los valores reales, también descartaremos algunas variables que tienen una gran cantidad de NA's (esto se vio en el análisis exploratorio)

```{r}

ncores <- min(detectCores() - 1, 24)


data_to_cluster <- train_imp %>% select(-ratio_age) %>% select(-VIC_EDAD) %>% select(-AGR_EDAD)


qualitative_vars <- c(
  "HEC_DEPTO", "DEPTO_MUNICIPIO", "QUIEN_REPORTA", "VIC_SEXO", 
  "VIC_ALFAB", "VIC_ESCOLARIDAD", "VIC_EST_CIV", "VIC_GRUPET", 
  "VIC_NACIONAL", "VIC_TRABAJA", "VIC_OCUP", "VIC_DEDICA", 
  "VIC_DISC", "TIPO_DISCAQ", "HEC_AREA", "HEC_TIAGRE", 
  "HEC_RECUR_DENUN", "INST_DONDE_DENUNCIO", "AGR_SEXO", 
  "AGR_ALFAB", "AGR_ESCOLARIDAD", "AGR_EST_CIV", "AGR_GRUPET", 
  "AGR_NACIONAL", "AGR_TRABAJA", "AGR_OCUP", "AGR_DEDICA", 
  "INST_DENUN_HECHO", "ORGANISMO_JURISDICCIONAL", "CONDUCENTE", 
  "MEDIDAS_SEGURIDAD", "LEY_APLICABLE", "ARTICULOVIF", 
  "ARTICULOVCM", "ARTICULOCODPEN", "ARTICULOTRAS", 
  "TIPO_MEDIDA", "ORGANISMO_REMITE"
)

#Mapear

deptos_mapping <- data.frame(
  departamento = 1:22,
  dep_nombre = c("Guatemala", "El Progreso", "Sacatepéquez", "Chimaltenango", 
                   "Escuintla", "Santa Rosa", "Sololá", "Totonicapán", 
                   "Quetzaltenango", "Suchitepéquez", "Retalhuleu", "San Marcos",
                   "Huehuetenango", "Quiché", "Baja Verapaz", "Alta Verapaz", 
                   "Petén", "Izabal", "Zacapa", "Chiquimula", "Jalapa", "Jutiapa")
)

estado_civil <- function(x) {
  case_when(
    x == 1 ~ "Soltero/a",
    x == 2 ~ "Casado/a",
    x == 3 ~ "Unido/a",
    x == 4 ~ "Viudo/a",
    x == 5 ~ "Otro",
    TRUE ~ NA_character_
  )
}

grupo_etnico <- function(x) {
  case_when(
    x == 1 ~ "Ladino(a)",
    x == 2 ~ "Maya",
    x == 3 ~ "Garífuna",
    x == 4 ~ "Xinka",
    x == 5 ~ "Otro",
    x == 6 ~ "No indica",
    TRUE ~ NA_character_
  )
}


alfabetismo_nivel <- function(x){
  case_when(
    x == 1 ~ "Alfabeta",
    x == 2 ~ "Analfabeta",
    TRUE ~ NA_character_
  )
}

dedicacion <- function(x) {
  case_when(
    x == 1 ~ "Quehaceres del hogar",
    x == 2 ~ "Renta o jubilación",
    x == 3 ~ "Estudiar",
    x == 4 ~ "Desempleado",
    x == 5 ~ "Otro",
    TRUE ~ NA_character_
  )
}

agresion_mapping <- data.frame(
  HEC_TIPAGRE = c(1222, 2122, 2212, 2221, 1122, 1212, 1221, 2112, 2121, 2211, 
                 1112, 1121, 2111, 1211, 1111),
  tipo_agresion = c("Física", "Psicológica", "Sexual", "Patrimonial", 
                   "Física - psicológica", "Física - sexual", "Física - patrimonial", 
                   "Psicológica - sexual", "Psicológica - patrimonial", 
                   "Sexual - patrimonial", "Física - psicológica - sexual", 
                   "Física - psicológica - patrimonial", 
                   "Psicológica - sexual - patrimonial", 
                   "Física - sexual - patrimonial", 
                   "Física - psicológica - sexual - patrimonial")
)

tipo_ley <- data.frame(
  LEY_APLICABLE = c(1,2,3,4,5,6,9),
  tipo_ley = c("Ley VIF ó Decreto 97-96", "Ley VCM ó Decreto 22-2008", "Ambas leyes (VIF y VCM)", 
               "Código Penal ó Decreto 17-73", "Otra", "Ley VIF y Código Penal", "Ignorado")
)

escolaridad_nivel <- function(x) {
  case_when(
    x == 10 ~ "Ninguno",
    x >= 21 & x <= 26 ~ "Primaria (1º a 6º)",
    x == 29 ~ "Primaria (ignorado)",
    x >= 31 & x <= 33 ~ "Básico (1º a 3º)",
    x == 39 ~ "Básico (ignorado)",
    x >= 44 & x <= 46 ~ "Diversificado (4º a 6º)",
    x == 49 ~ "Diversificado (ignorado)",
    x >= 51 & x <= 57 ~ "Universitario (1º a 7º)",
    x == 59 ~ "Universitario (ignorado)",
    TRUE ~ NA_character_
  )
}

data_to_cluster <- data_to_cluster %>% 
  left_join(deptos_mapping, by = c("HEC_DEPTO" = "departamento")) %>% mutate(HEC_DEPTO = dep_nombre) %>% select(-dep_nombre)

data_to_cluster <- data_to_cluster %>% 
  left_join(deptos_mapping, by = c("DEPTO" = "departamento")) %>% mutate(DEPTO = dep_nombre) %>% select(-dep_nombre)

data_to_cluster <- data_to_cluster %>% left_join(tipo_ley, by = "LEY_APLICABLE") %>%
  mutate(LEY_APLICABLE = tipo_ley) %>%
  select(-tipo_ley)

data_to_cluster <- data_to_cluster %>% 
  left_join(agresion_mapping, by = "HEC_TIPAGRE") %>%
  mutate(HEC_TIPAGRE = tipo_agresion) %>%
  select(-tipo_agresion)

data_to_cluster <- data_to_cluster %>%
  mutate(
    VIC_ESCOLARIDAD = escolaridad_nivel(VIC_ESCOLARIDAD)
  )

data_to_cluster <- data_to_cluster %>%
  mutate(
    VIC_DEDICA = dedicacion(VIC_DEDICA)
  )
data_to_cluster <- data_to_cluster %>%
  mutate(
    AGR_DEDICA = dedicacion(AGR_DEDICA)
  )

data_to_cluster <- data_to_cluster %>%
  mutate(
    AGR_ESCOLARIDAD = escolaridad_nivel(AGR_ESCOLARIDAD)
  )

data_to_cluster <- data_to_cluster %>% mutate(AGR_GURPET = grupo_etnico(AGR_GURPET))
data_to_cluster <- data_to_cluster %>% mutate(VIC_GRUPET = grupo_etnico(VIC_GRUPET))

data_to_cluster <- data_to_cluster %>%
  mutate(
    VIC_ALFAB = alfabetismo_nivel(VIC_ALFAB)
  )
data_to_cluster <- data_to_cluster %>%
  mutate(
    AGR_ALFAB = alfabetismo_nivel(AGR_ALFAB)
  )

data_to_cluster <- data_to_cluster %>% 
  mutate(
    VIC_EST_CIV = factor(VIC_EST_CIV, levels = 1:5,
                         labels = c("Soltero/a", "Casado/a", "Unido/a", 
                                    "Viudo/a", "Otro")),
    AGR_EST_CIV = factor(AGR_EST_CIV, levels = 1:5,
                         labels = c("Soltero/a", "Casado/a", "Unido/a", 
                                    "Viudo/a", "Otro"))
  )

data_to_cluster <- data_to_cluster %>%   mutate(HEC_AREA = factor(HEC_AREA, levels = c(1, 2), 
                     labels = c("Urbana", "Rural")))

data_to_cluster <- data_to_cluster %>% mutate(VIC_TRABAJA = factor(VIC_TRABAJA, levels = c(1, 2), 
                              labels = c("Víctima trabaja", "Víctima No trabaja")),
         AGR_TRABAJA = factor(AGR_TRABAJA, levels = c(1, 2), 
                              labels = c("Agresor trabaja", "Agresor No trabaja")))

data_to_cluster <- data_to_cluster %>% mutate(HEC_RECUR_DENUN = factor(HEC_RECUR_DENUN, levels = c(1,2), labels = c("Si", "No")))



data_to_cluster <- data_to_cluster %>% mutate(VIC_DISC = factor(VIC_DISC, levels = c(1,2), labels = c("Con discapacidad", "Sin discapacidad")))
data_to_cluster <- data_to_cluster %>% mutate(VIC_REL_AGR = factor(VIC_REL_AGR, levels = c(1,2,3,4,5,6,7,8,9,10), labels = c("Esposo/a", "Conviviente", "Exconviviente", "Hijos/a","Hijastros/a", "Padre/Madre", "Nieto/a", "Suegro/a", "Hermano/a", "Otro pariente")))
data_to_cluster <- data_to_cluster %>% mutate(TIPO_DISCAQ = factor(TIPO_DISCAQ, levels = c(1,2,3,4,5,6), labels = c("Ceguera", "Sordera", "Discapacidad extremidades superiores", "Discapacidad extremidades inferiores", "Deficiencia mental", "Otra discapacidad")))
data_to_cluster <- data_to_cluster %>% 
  mutate(INST_DONDE_DENUNCIO = factor(INST_DONDE_DENUNCIO, 
                                      levels = c(1, 2, 3, 4, 5, 6), 
                                      labels = c("Ministerio Público", 
                                                "Procuraduría General de la Nación", 
                                                "Policía Nacional Civil", 
                                                "Organismo Judicial", 
                                                "Bufetes Populares", 
                                                "Procuraduría de los Derechos Humanos")))


data_to_cluster <- data_to_cluster %>% mutate(QUIEN_REPORTA = factor(QUIEN_REPORTA, levels = c(1,2,3), labels = c("Víctima", "Familiar de la víctima", "Otros")))

data_to_cluster <- data_to_cluster %>% 
  mutate(
    AGR_SEXO = factor(AGR_SEXO, 
                     levels = c(1, 2), 
                     labels = c("Hombre", "Mujer")),
    VIC_SEXO = factor(VIC_SEXO, 
                     levels = c(1, 2), 
                     labels = c("Hombre", "Mujer"))
  )

data_to_cluster <- data_to_cluster %>% 
  mutate(
    VIC_NACIONAL = factor(VIC_NACIONAL, 
                     levels = c(1, 2), 
                     labels = c("Guatemalteca", "Extranjera")),
    AGR_NACIONAL = factor(AGR_NACIONAL, 
                     levels = c(1, 2), 
                     labels = c("Guatemalteca", "Extranjera"))
  )

data_to_cluster <- data_to_cluster %>% 
  mutate(
    INST_DENUN_HECHO = factor(INST_DENUN_HECHO, 
                             levels = c(1, 2, 3, 4, 5, 6), 
                             labels = c("Ministerio Público", 
                                       "Procuraduría General de la Nación", 
                                       "Policía Nacional Civil", 
                                       "Organismo Judicial", 
                                       "Bufetes Populares", 
                                       "Procuraduría de los Derechos Humanos"))
  )

data_to_cluster <- data_to_cluster %>% 
  mutate(
    ORGANISMO_JURISDICCIONAL = factor(ORGANISMO_JURISDICCIONAL, 
                                      levels = 1:16, 
                                      labels = c(
                                        "Juzgados de Paz",
                                        "Juzgados de Paz Comunitarios",
                                        "Juzgados de Paz Penal",
                                        "Juzgado de Paz Penal de Conocimiento a Prevención de Delitos de Narcotráfico, Defraudación y Contrabando Aduanero, Violencia Sexual, Explotación y Trata de Personas",
                                        "Juzgados de Paz Penal de Turno/24horas",
                                        "Juzgados de Paz Móvil",
                                        "Juzgado de Paz con Competencia Específica para la Protección en Materia de Violencia Intrafamiliar, y de Niñez y Adolescencia Amenazada o Violada en sus Derechos (de turno)",
                                        "Juzgados de Primera Instancia Penal, Narcoactividad y Delitos contra el Ambiente",
                                        "Juzgados de Primera Instancia Penal, Narcoactividad y Delitos contra el Ambiente de Turno/24 horas",
                                        "Juzgado de Turno de Primera Instancia Penal de Delitos de Femicidio y otras formas de Violencia contra la contra la Mujer y Violencia Sexual, Explotación y Trata de Personas",
                                        "Juzgados de Primera Instancia Penal de Delitos de Femicidio y otras formas de Violencia contra la Mujer",
                                        "Tribunales de Sentencia Penal, Narcoactividad y Delitos contra el Ambiente",
                                        "Tribunales de Sentencia Penal de Delitos de Femicidio y otras formas de Violencia en contra de la Mujer",
                                        "Juzgados de Primera Instancia Ramo Mixto",
                                        "Juzgados de Primera Instancia de Familia",
                                        "Juzgados de Adolescentes en Conflicto con la Ley Penal"
                                      ))
  )

data_to_cluster <- data_to_cluster %>% 
  mutate(
    CONDUCENTE = factor(CONDUCENTE, 
                        levels = c(1, 2), 
                        labels = c("Si", "No"))
  )

data_to_cluster <- data_to_cluster %>% 
  mutate(
    MEDIDAS_SEGURIDAD = factor(MEDIDAS_SEGURIDAD, 
                              levels = c(1, 2), 
                              labels = c("Medidas otorgadas", 
                                        "Medidas no otorgadas"))
  )

data_to_cluster <- data_to_cluster %>% 
  mutate(
    ORGANISMO_REMITE = factor(ORGANISMO_REMITE, 
                             levels = 1:18, 
                             labels = c(
                               "Juzgados de Paz",
                               "Juzgados de Paz Comunitarios",
                               "Juzgados de Paz Penal",
                               "Juzgado de Paz Penal de Conocimiento a Prevención de Delitos de Narcotráfico, Defraudación y Contrabando Aduanero, Violencia Sexual, Explotación y Trata de Personas",
                               "Juzgados de Paz Penal de Turno/24horas",
                               "Juzgados de Paz Móvil",
                               "Juzgado de Paz con Competencia Específica para la Protección en Materia de Violencia Intrafamiliar, y de Niñez y Adolescencia Amenazada o Violada en sus Derechos (de turno)",
                               "Juzgados de Primera Instancia Penal, Narcoactividad y Delitos contra el Ambiente",
                               "Juzgados de Primera Instancia Penal, Narcoactividad y Delitos contra el Ambiente de Turno/24 horas",
                               "Juzgado de Turno de Primera Instancia Penal de Delitos de Femicidio y otras formas de Violencia contra la contra la Mujer y Violencia Sexual, Explotación y Trata de Personas",
                               "Juzgados de Primera Instancia Penal de Delitos de Femicidio y otras formas de Violencia en contra de la Mujer",
                               "Tribunales de Sentencia Penal, Narcoactividad y Delitos contra el Ambiente",
                               "Tribunales de Sentencia Penal de Delitos de Femicidio y otras formas de Violencia en contra de la Mujer",
                               "Juzgados de Primera Instancia Ramo Mixto",
                               "Juzgados de Primera Instancia de Familia",
                               "Juzgados de Adolescentes en Conflicto con la Ley Penal",
                               "Ministerio Público (como órgano estatal)",
                               "Este mismo órgano"
                             ))
  )
data_to_cluster <- data_to_cluster %>% select(-HEC_DIA)  %>% select(-HEC_DEPTOMCPIO) %>% select(-NUMERO_BOLETA) %>% select(-DIA_EMISION) %>% select(-TIPO_MEDIDA) %>% select(-ARTICULOVIF1) %>% select(-ARTICULOVIF2) %>% select(-ARTICULOVIF3) %>% select(-ARTICULOVIF4) %>% select(-ARTICULOVCM1) %>% select(-ARTICULOVCM2) %>% select(-ARTICULOVCM3) %>% select(-ARTICULOVCM4) %>% select(-ARTICULOCODPEN1) %>% select(-ARTICULOCODPEN2) %>% select(-ARTICULOCODPEN3) %>% select(-ARTICULOCODPEN4) %>% select(-ARTICULOTRAS1) %>% select(-ARTICULOTRAS2) %>% select(-ARTICULOTRAS3) %>% select(-ARTICULOTRAS4) %>% select(-DEPTO_MCPIO) %>% select(-VIC_OCUP) %>% select(-AGR_OCUP)

data_to_cluster<-data_to_cluster %>% mutate_if(is.character,as.factor)


```


```{r}



# Crear data_to_train a partir de train_imp
data_to_train <- test_imp

# Aplicar las mismas transformaciones
# 1. Mapeos de departamentos
data_to_train <- data_to_train %>% 
  left_join(deptos_mapping, by = c("HEC_DEPTO" = "departamento")) %>% 
  mutate(HEC_DEPTO = dep_nombre) %>% 
  select(-dep_nombre)

data_to_train <- data_to_train %>% 
  left_join(deptos_mapping, by = c("DEPTO" = "departamento")) %>% 
  mutate(DEPTO = dep_nombre) %>% 
  select(-dep_nombre)

# 2. Mapeo de leyes aplicables
data_to_train <- data_to_train %>% 
  left_join(tipo_ley, by = "LEY_APLICABLE") %>%
  mutate(LEY_APLICABLE = tipo_ley) %>%
  select(-tipo_ley)

# 3. Mapeo de tipos de agresión
data_to_train <- data_to_train %>% 
  left_join(agresion_mapping, by = "HEC_TIPAGRE") %>%
  mutate(HEC_TIPAGRE = tipo_agresion) %>%
  select(-tipo_agresion)

# 4. Transformaciones de escolaridad
data_to_train <- data_to_train %>%
  mutate(
    VIC_ESCOLARIDAD = escolaridad_nivel(VIC_ESCOLARIDAD),
    AGR_ESCOLARIDAD = escolaridad_nivel(AGR_ESCOLARIDAD)
  )

# 5. Transformaciones de dedicación
data_to_train <- data_to_train %>%
  mutate(
    VIC_DEDICA = dedicacion(VIC_DEDICA),
    AGR_DEDICA = dedicacion(AGR_DEDICA)
  )

# 6. Transformaciones de grupo étnico
data_to_train <- data_to_train %>% 
  mutate(
    AGR_GURPET = grupo_etnico(AGR_GURPET),
    VIC_GRUPET = grupo_etnico(VIC_GRUPET)
  )

# 7. Transformaciones de alfabetismo
data_to_train <- data_to_train %>%
  mutate(
    VIC_ALFAB = alfabetismo_nivel(VIC_ALFAB),
    AGR_ALFAB = alfabetismo_nivel(AGR_ALFAB)
  )

# 8. Transformaciones de estado civil
data_to_train <- data_to_train %>% 
  mutate(
    VIC_EST_CIV = factor(VIC_EST_CIV, levels = 1:5,
                         labels = c("Soltero/a", "Casado/a", "Unido/a", 
                                    "Viudo/a", "Otro")),
    AGR_EST_CIV = factor(AGR_EST_CIV, levels = 1:5,
                         labels = c("Soltero/a", "Casado/a", "Unido/a", 
                                    "Viudo/a", "Otro"))
  )

# 9. Transformación de área
data_to_train <- data_to_train %>%   
  mutate(HEC_AREA = factor(HEC_AREA, levels = c(1, 2), 
                     labels = c("Urbana", "Rural")))

# 10. Transformación de trabajo
data_to_train <- data_to_train %>% 
  mutate(
    VIC_TRABAJA = factor(VIC_TRABAJA, levels = c(1, 2), 
                          labels = c("Víctima trabaja", "Víctima No trabaja")),
    AGR_TRABAJA = factor(AGR_TRABAJA, levels = c(1, 2), 
                          labels = c("Agresor trabaja", "Agresor No trabaja"))
  )

# 11. Transformación de recurso de denuncia
data_to_train <- data_to_train %>% 
  mutate(HEC_RECUR_DENUN = factor(HEC_RECUR_DENUN, levels = c(1,2), labels = c("Si", "No")))

# 12. Transformación de discapacidad
data_to_train <- data_to_train %>% 
  mutate(
    VIC_DISC = factor(VIC_DISC, levels = c(1,2), labels = c("Con discapacidad", "Sin discapacidad")),
    TIPO_DISCAQ = factor(TIPO_DISCAQ, levels = c(1,2,3,4,5,6), 
                         labels = c("Ceguera", "Sordera", "Discapacidad extremidades superiores", 
                                   "Discapacidad extremidades inferiores", "Deficiencia mental", 
                                   "Otra discapacidad"))
  )

# 13. Transformación de relación víctima-agresor
data_to_train <- data_to_train %>% 
  mutate(VIC_REL_AGR = factor(VIC_REL_AGR, levels = c(1,2,3,4,5,6,7,8,9,10), 
                             labels = c("Esposo/a", "Conviviente", "Exconviviente", 
                                       "Hijos/a","Hijastros/a", "Padre/Madre", 
                                       "Nieto/a", "Suegro/a", "Hermano/a", "Otro pariente")))

# 14. Transformación de institución
data_to_train <- data_to_train %>% 
  mutate(INST_DONDE_DENUNCIO = factor(INST_DONDE_DENUNCIO, 
                                      levels = c(1, 2, 3, 4, 5, 6), 
                                      labels = c("Ministerio Público", 
                                                "Procuraduría General de la Nación", 
                                                "Policía Nacional Civil", 
                                                "Organismo Judicial", 
                                                "Bufetes Populares", 
                                                "Procuraduría de los Derechos Humanos")))

# 15. Transformación de quien reporta
data_to_train <- data_to_train %>% 
  mutate(QUIEN_REPORTA = factor(QUIEN_REPORTA, levels = c(1,2,3), 
                               labels = c("Víctima", "Familiar de la víctima", "Otros")))

# 16. Transformación de sexo
data_to_train <- data_to_train %>% 
  mutate(
    AGR_SEXO = factor(AGR_SEXO, levels = c(1, 2), labels = c("Hombre", "Mujer")),
    VIC_SEXO = factor(VIC_SEXO, levels = c(1, 2), labels = c("Hombre", "Mujer"))
  )

# 17. Transformación de nacionalidad
data_to_train <- data_to_train %>% 
  mutate(
    VIC_NACIONAL = factor(VIC_NACIONAL, levels = c(1, 2), labels = c("Guatemalteca", "Extranjera")),
    AGR_NACIONAL = factor(AGR_NACIONAL, levels = c(1, 2), labels = c("Guatemalteca", "Extranjera"))
  )

# 18. Transformación de institución de denuncia
data_to_train <- data_to_train %>% 
  mutate(
    INST_DENUN_HECHO = factor(INST_DENUN_HECHO, 
                             levels = c(1, 2, 3, 4, 5, 6), 
                             labels = c("Ministerio Público", 
                                       "Procuraduría General de la Nación", 
                                       "Policía Nacional Civil", 
                                       "Organismo Judicial", 
                                       "Bufetes Populares", 
                                       "Procuraduría de los Derechos Humanos"))
  )

# 19. Transformación de organismo jurisdiccional
data_to_train <- data_to_train %>% 
  mutate(
    ORGANISMO_JURISDICCIONAL = factor(ORGANISMO_JURISDICCIONAL, 
                                      levels = 1:16, 
                                      labels = c(
                                        "Juzgados de Paz",
                                        "Juzgados de Paz Comunitarios",
                                        "Juzgados de Paz Penal",
                                        "Juzgado de Paz Penal de Conocimiento a Prevención de Delitos de Narcotráfico, Defraudación y Contrabando Aduanero, Violencia Sexual, Explotación y Trata de Personas",
                                        "Juzgados de Paz Penal de Turno/24horas",
                                        "Juzgados de Paz Móvil",
                                        "Juzgado de Paz con Competencia Específica para la Protección en Materia de Violencia Intrafamiliar, y de Niñez y Adolescencia Amenazada o Violada en sus Derechos (de turno)",
                                        "Juzgados de Primera Instancia Penal, Narcoactividad y Delitos contra el Ambiente",
                                        "Juzgados de Primera Instancia Penal, Narcoactividad y Delitos contra el Ambiente de Turno/24 horas",
                                        "Juzgado de Turno de Primera Instancia Penal de Delitos de Femicidio y otras formas de Violencia contra la contra la Mujer y Violencia Sexual, Explotación y Trata de Personas",
                                        "Juzgados de Primera Instancia Penal de Delitos de Femicidio y otras formas de Violencia contra la Mujer",
                                        "Tribunales de Sentencia Penal, Narcoactividad y Delitos contra el Ambiente",
                                        "Tribunales de Sentencia Penal de Delitos de Femicidio y otras formas de Violencia en contra de la Mujer",
                                        "Juzgados de Primera Instancia Ramo Mixto",
                                        "Juzgados de Primera Instancia de Familia",
                                        "Juzgados de Adolescentes en Conflicto con la Ley Penal"
                                      ))
  )

# 20. Transformación de conducente
data_to_train <- data_to_train %>% 
  mutate(
    CONDUCENTE = factor(CONDUCENTE, levels = c(1, 2), labels = c("Si", "No"))
  )

# 21. Transformación de medidas de seguridad
data_to_train <- data_to_train %>% 
  mutate(
    MEDIDAS_SEGURIDAD = factor(MEDIDAS_SEGURIDAD, 
                              levels = c(1, 2), 
                              labels = c("Medidas otorgadas", "Medidas no otorgadas"))
  )

# 22. Transformación de organismo que remite
data_to_train <- data_to_train %>% 
  mutate(
    ORGANISMO_REMITE = factor(ORGANISMO_REMITE, 
                             levels = 1:18, 
                             labels = c(
                               "Juzgados de Paz",
                               "Juzgados de Paz Comunitarios",
                               "Juzgados de Paz Penal",
                               "Juzgado de Paz Penal de Conocimiento a Prevención de Delitos de Narcotráfico, Defraudación y Contrabando Aduanero, Violencia Sexual, Explotación y Trata de Personas",
                               "Juzgados de Paz Penal de Turno/24horas",
                               "Juzgados de Paz Móvil",
                               "Juzgado de Paz con Competencia Específica para la Protección en Materia de Violencia Intrafamiliar, y de Niñez y Adolescencia Amenazada o Violada en sus Derechos (de turno)",
                               "Juzgados de Primera Instancia Penal, Narcoactividad y Delitos contra el Ambiente",
                               "Juzgados de Primera Instancia Penal, Narcoactividad y Delitos contra el Ambiente de Turno/24 horas",
                               "Juzgado de Turno de Primera Instancia Penal de Delitos de Femicidio y otras formas de Violencia contra la contra la Mujer y Violencia Sexual, Explotación y Trata de Personas",
                               "Juzgados de Primera Instancia Penal de Delitos de Femicidio y otras formas de Violencia en contra de la Mujer",
                               "Tribunales de Sentencia Penal, Narcoactividad y Delitos contra el Ambiente",
                               "Tribunales de Sentencia Penal de Delitos de Femicidio y otras formas de Violencia en contra de la Mujer",
                               "Juzgados de Primera Instancia Ramo Mixto",
                               "Juzgados de Primera Instancia de Familia",
                               "Juzgados de Adolescentes en Conflicto con la Ley Penal",
                               "Ministerio Público (como órgano estatal)",
                               "Este mismo órgano"
                             ))
  )

# 23. Eliminar columnas no necesarias (como se hizo en data_to_cluster)
data_to_train <- data_to_train %>% 
  select(-HEC_DIA) %>% 
  select(-HEC_DEPTOMCPIO) %>% 
  select(-NUMERO_BOLETA) %>% 
  select(-DIA_EMISION) %>% 
  select(-TIPO_MEDIDA) %>% 
  select(-ARTICULOVIF1) %>% 
  select(-ARTICULOVIF2) %>% 
  select(-ARTICULOVIF3) %>% 
  select(-ARTICULOVIF4) %>% 
  select(-ARTICULOVCM1) %>% 
  select(-ARTICULOVCM2) %>% 
  select(-ARTICULOVCM3) %>% 
  select(-ARTICULOVCM4) %>% 
  select(-ARTICULOCODPEN1) %>% 
  select(-ARTICULOCODPEN2) %>% 
  select(-ARTICULOCODPEN3) %>% 
  select(-ARTICULOCODPEN4) %>% 
  select(-ARTICULOTRAS1) %>% 
  select(-ARTICULOTRAS2) %>% 
  select(-ARTICULOTRAS3) %>% 
  select(-ARTICULOTRAS4) %>% 
  select(-DEPTO_MCPIO) %>% 
  select(-VIC_OCUP) %>% 
  select(-AGR_OCUP)




data_to_train <- data_to_train %>% select(-ratio_age) %>% select(-VIC_EDAD) %>% select(-AGR_EDAD)
data_to_train<-data_to_train %>% mutate_if(is.character,as.factor)

```


```{r}
modelo_arbol <- rpart(diferenciaEdad ~ .,  method = "class", data = data_to_cluster)


# Configurar el entorno gráfico
par(mar = c(0.5, 0.5, 2, 0.5))  # Márgenes mínimos
options(repr.plot.width = 15, repr.plot.height = 12)  # Aumentar tamaño

# Visualización del árbol
rpart.plot(modelo_arbol,
           type = 2,               
           extra = 2,               
           box.palette = "RdYlGn",  
           branch.lwd = 1.2,        
           fallen.leaves = TRUE,    
           under = TRUE,            
           space = 0.5,             
           gap = 3,                 
           compress = FALSE,        
           main = "Árbol de Clasificación para la diferencia de edad",
           cex = 0.8,               
           tweak = 1.2,             
           digits = 2)              # Redondear valores numéricos
```

Ahora hacemos las predicciones

```{r}

new_pred <- predict(modelo_arbol, newdata = data_to_train, type = "class")

conf_mat <- confusionMatrix(new_pred, data_to_train$diferenciaEdad)

conf_mat

```
El primer modelo tuvo un accuracy de 0.59 y un kappa value de 0.38, esto indica que puede mejorarse bastante, además muestra dificultad identificando una diferencia de edad mucho menor y una diferencia deedad mucho mayor, por lo tanto, se tunearan los hiperparámetros como la profundiad para ver si hay un modelo mejor. 



```{r}

modelo_intermedio <- rpart(
  diferenciaEdad ~ .,
  data = data_to_cluster,
  method = "class",
  control = rpart.control(
    maxdepth = 8,           # Profundidad moderada
    minsplit = 15,          # Balance en división
    minbucket = 7,          # Balance en hojas
    cp = 0.005,             # Factor de complejidad moderado
    xval = 10
  )
)

intermed_pred <- predict(modelo_intermedio, newdata = data_to_train, type = "class")

conf_mat2 <- confusionMatrix(intermed_pred, data_to_train$diferenciaEdad)

conf_mat2


```

Vemos que el modelo mejoró encontrando las clases de mucho mayor y mucho menor, sin embargo disminuyó su rendimiento a la hora de encontrar datos con categoría "similar"

```{r}
modelo_agresivo <- rpart(
  diferenciaEdad ~ .,
  data = data_to_cluster,
  method = "class",
  control = rpart.control(
    maxdepth = 15,          # Muy profundo
    minsplit = 5,           # Pocas observaciones para dividir
    minbucket = 2,          # Muy pocas observaciones por hoja
    cp = 0.001,             # Factor de complejidad muy bajo
    xval = 10
  )
)

agre_pred <- predict(modelo_agresivo, newdata = data_to_train, type = "class")

conf_mat3 <- confusionMatrix(agre_pred, data_to_train$diferenciaEdad)

conf_mat3

```


Se generaron 6 modelos más de árboles de clasificación, cambiando la profundidad del árbol, se puede observar qe tanto el kappa value como el accuracy no mejoran de manera significativa con respecto al modelo incial ya que el accuracy se mantiene en 0.72 y el kappa value en 0.39. Con esta información se puede concluir que el modelo de árbol de clasificación no es beneficioso para realizar predicciones sobre nuestra variable respuesta ya que tiene problemas en identificar las categorías establecidas. Esta dificultad de identificación puede deberse a la distribución de las categorías en el conjunto de datos de entrenamiento. 

## Regresión logística

```{r, echo= FALSE}

modelo_conservador <- multinom(diferenciaEdad ~., 
                              data = data_to_cluster,
                              maxit = 100,
                              trace = FALSE)

# Evaluar modelo conservador
pred_conservador <- predict(modelo_conservador, data_to_train, type = "class")
prob_conservador <- predict(modelo_conservador, data_to_train, type = "probs")

cm_conservador <- confusionMatrix(pred_conservador, data_to_train$diferenciaEdad)

cm_conservador

```
```{r}
cv_control <- trainControl(
  method = "cv",
  number = 5,
  classProbs = TRUE,
  summaryFunction = multiClassSummary
)



train_intermedio <- data_to_cluster[complete.cases(data_to_cluster), ]
test_intermedio <- data_to_train[complete.cases(data_to_train), ]

train_intermedio$diferenciaEdad <- as.factor(gsub(" ", "_", as.character(train_intermedio$diferenciaEdad)))
test_intermedio$diferenciaEdad <- as.factor(gsub(" ", "_", as.character(test_intermedio$diferenciaEdad)))
registerDoSEQ() 

# Modelo con regularización elastic net (alpha = 0.5 para balance lasso/ridge)
# Luego vuelve a correr train()
modelo_intermedio <- train(
  diferenciaEdad ~ .,
  data = train_intermedio,
  method = "glmnet",
  trControl = cv_control,
  tuneGrid = expand.grid(
    alpha = 0.5,
    lambda = seq(0.001, 0.1, length = 20)
  ),
  metric = "Accuracy"
)
pred_intermedio <- predict(modelo_intermedio, test_intermedio)
cm_intermedio <- confusionMatrix(pred_intermedio, test_intermedio$diferenciaEdad)

cm_intermedio
```
```{r}
modelo_agresivo <- train(
  diferenciaEdad ~.,
  data = train_intermedio,
  method = "glmnet",
  trControl = trainControl(method = "cv", number = 3),  # CV más rápido
  tuneGrid = expand.grid(
    alpha = 0.01,  # Poca regularización
    lambda = seq(0.0001, 0.01, length = 10)  # Lambda muy pequeño
  ),
  metric = "Accuracy",
  family = "multinomial"
)
pred_agresivo <- predict(modelo_agresivo, test_intermedio)
cm_agresivo <- confusionMatrix(pred_agresivo, test_intermedio$diferenciaEdad)

cm_agresivo
```


